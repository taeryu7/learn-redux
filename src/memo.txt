리덕스
리덕스는 리액트 생태계에서 가장 사용률이 높은 상태관리 라이브러리다.
리덕스를 사용하면 만들게 될 컴포넌트들의 상태 관련 로직들을 다른 파일들로 분리시켜서 더욱 효율적으로 관리 할 수 있으며 글로벌 상태관리도 쉬워진다.
Context API를 사용해도 글로벌 상태관리를 할 수있고 상태관리 로직을 분리 할 수 있다.
Context API 와 useReducer Hook 을 사용해서 개발하는 흐름은 리덕스를 사용하는 것과 매우 개발 방식이 유사하다. 
리덕스에서도 리듀서와 액션이라는 개념을 사용한다.

Redux는 Context API 가 지금의 형태로 사용방식이 개선되기도 전에, useReducer 라는 Hook 이 존재하기도 전 부터 만들어진 라이브러리다.
Context API가 개선되기 전에 프로젝트에서 글로벌 상태관리하기가 어려웠었다. 그래서 리덕스가 글로벌 관리 용도로 많이 사용되어 왔다.

npmtrends ↓ 를 통해 알 수 있는 사실은, 리액트를 사용하는 프로젝트 45%가 리덕스를 사용하고 있다.
https://npmtrends.com/react-vs-react-redux-vs-redux

redux 는 리액트에서 사용하기 위해 만들어진 라이브러리이긴 하지만 무조건 리액트와 함께 사용 할 필요는 없다.
일반 JavaScript 환경에서 사용 할 수도 있고 Angular 와 같은 다른 프레임워크에서도 사용되기도 한다.
이러한 이유 때문에 react-redux 보다 redux 의 다운로드 수치가 훨씬 높다.

리덕스가 많이 사용된다고 해서 무조건 리덕스를 써야할 필요는 없다.
어느 도구나 마찬가지로 잘 활용하면 상황에 따라, 취향에 따라 개발 생산성이 좋아질 수 있다.
단순히 글로벌 상태 관리를 위한 것이다면 Context API를 활용하는것만으로 충분 할 수 있다.

리덕스를 사용하는 것 과 Context API를 사용하는 것의 차이
1. 미들웨어
리덕스에는 미들웨어(Middleware)라는 개념이 존재한다. 리덕스로 상태관리를 할 때에 useReducer를 사용할때 접한 리듀서 함수를 사용한다.
리덕스의 미들웨어를 사용하면 액션객체가 리듀서에서 처리되기전에 원하는 작업들을 수행 할 수 있다.
(↓아래에 예시들)

특정 조건에 따라 액션이 무시되게 만들 수 있다.
액션을 콘솔에 출력하거나, 서버쪽에 로깅을 할 수 있다.
액션이 디스패치 됐을 때 이를 수정해서 리듀서에게 전달되도록 할 수 있다.
특정 액션이 발생했을 때 이에 기반하여 다른 액션이 발생되도록 할 수 있다.
특정 액션이 발생했을 때 특정 자바스크립트 함수를 실행시킬 수 있다.

미들웨어는 주로 비동기 잡업을 처리 할때 많이 사용된다.
useReducer Hook 에서도 외부 라이브러리를 사용하면 미들웨어를 사용 할 수도 있다. 자주 사용되는 방식은 아니다.



유용한 함수와, Hooks
Context API와 useReducer를 사용할 때 Context도 새로 만들고, Context의 Provider 설정도 하고,
각 Context를 편하게 사용하기 위해 전용 커스텀 Hook을 새로 만들어서 사용했는데, 리덕스에서 이와 비슷한 작업을 편리하게 해주는 기능이 있다.

connect 함수를 사용하면 리덕스의 상태 또는 액션 생성 함수를 컴포넌트의 props 로 받아올 수 있으며, 
useSelector, useDispatch, useStore 과 같은 Hooks를 사용하면 손쉽게 상태를 조회하거나 액션을 디스패치 할 수 있다.

connect 함수와 useSelector 함수에는 내부적으로 최적화가 잘 이루어져있어서 실제 상태가 바뀔때만 컴포넌트가 리렌더링된다.
Context API를 사용할 때에는 그러한 최적화가 자동으로 이루어져있지 않기 때문에
Context 가 지니고 있는 상태가 바뀌면 해당 Context 의 Provider 내부 컴포넌트들이 모두 리렌더링된다.



// 하나의 커다란 상태
Context API 를 사용해서 글로벌 상태를 관리 할 때에는 일반적으로 기능별로 Context를 만들어서 사용하는 것이 일반적이다.
리덕스에서는 모든 글로벌 상태를 하나의 커다란 객체에 넣어서 사용하는것이 필수다.
디럭스를 사용하면 매번 Context를 새로 만드는 수고를 덜 수 있다


리덕스를 써야하는 상황 정리 

1. 프로젝트의 규모가 큰가?
Yes: 리덕스
No: Context API

2. 비동기 작업을 자주 하게 되는가?
Yes: 리덕스
No: Context API

3. 리덕스를 배워보니까 사용하는게 편한가?
Yes: 리덕스
No: Context API 또는 MobX



리덕스에서 사용되는 키워드 숙지하기

액션 (Action)
상태에 어떠한 변화가 필요하게 될 때 액션이라는것을 발생시킨다.
↓이는 하나의 객체로 표현되고 아래와 같은 형식으로 이루어져있다.
{
  type: "TOGGLE_VALUE"
}

액션 객체는 type 필드를 필수적으로 가지고 있어야하고 그 외의 값들은 개발자 마음대로 넣어줄 수 있다.
{
  type: "ADD_TODO",
  data: {
    id: 0,
    text: "리덕스 배우기"
  }
}
{
  type: "CHANGE_INPUT",
  text: "안녕하세요"
}

액션함수 생성(Action Creator)
액션 생성함수는, 액션을 만드는 함수로, 단순하게 파라미터를 받아와서 액션객체 형태로 만들어준다.
export function addTodo(data) {
  return {
    type: "ADD_TODO",
    data
  };
}
// 화살표 함수로도 만들 수 있다.
export const changeInput = text => ({ 
  type: "CHANGE_INPUT",
  text
});
↑위에같은 액션함수를 만들어서 사용하는 이유는 나중에 컴포넌트에서 더욱 쉽게 액션을 발생시키기 위함이다.
보통 함수 앞에 export 키워드를 붙여서 다른 파일에서 불러와서 사용한다.
리덕스를 사용 할 때 액션 생성함수를 사용하는것이 필수는 아니다. 액션을 발생 시킬때마다 직접 액션객체를 작성 할 수 있다.


리듀서 (Reducer)
리듀서는 변화를 일으키는 함수다. 리듀서는 두가지의 파라미터를 받아온다.

function reducer(state, action) {
  // 상태 업데이트 로직
  return alteredState;
}
리듀서는 현재의 상태와, 전달 받은 액션을 참고하여 새로운 상태를 만들어서 반환한다.
리듀서는 useReducer 를 사용할때 작성하는 리듀서와 똑같은 형태를 가지고있다.

↓카운터를 위한 리듀서를 작성한다면 아래와 같이 작성 할 수 있다.
function counter(state, action) {
  switch (action.type) {
    case 'INCREASE':
      return state + 1;
    case 'DECREASE':
      return state - 1;
    default:
      return state;
  }
}

useReducer 에선 일반적으로 default: 부분에 throw new Error('Unhandled Action')과 같이 에러를 발생시키도록 처리하는게 일반적인 반면,
리덕스의 리듀서에서는 기존 state를 그대로 반환하도록 작성해야한다.
리덕스를 사용 할 때에는 여러개의 리듀서를 만들고 이를 합쳐서 루트 리듀서 (Root Reducer)를 만들 수 있다.
루트 리듀서 안의 작은 리듀서들은 서브 리듀서라고 부른다.


스토어 (Store)
리덕스에서는 한 애플리케이션당 하나의 스토어를 만들게된다.
스토어 안에는, 현재의 앱 상태와, 리듀서가 들어가있고, 추가적으로 몇가지 내장 함수들이 있다.


디스패치 (dispatch)
디스패치는 스토어의 내장함수 중 하나다. 디스패치는 액션을 발생시키는것 이라고 생각하면 된다.
dispatch 라는 함수에는 액션을 파라미터로 전달한다. (ex. dispatch(action) 이런식)
호출을 하면, 스토어는 리듀서 함수를 실행시켜서 해당 액션을 처리하는 로직이 있다면 액션을 참고하여 새로운 상태를 만들어준다.

구독 (subscribe)
구독 또한 스토어의 내장함수 중 하나다. subscribe 함수는, 함수 형태의 값을 파라미터로 받아온다.
subscribe 함수에 특정 함수를 전달해주면, 액션이 디스패치 되었을 때 마다 전달해준 함수가 호출된다.
리액트에서 리덕스를 사용하게 될 때 보통 이 함수를 직접 사용하는 일은 별로 없다. 
대신 react-redux 라는 라이브러리에서 제공하는 connect 함수 또는 useSelector Hook 을 사용하여 리덕스 스토어의 상태에 구독한다.

리덕스 키워드

액션 (Action)
상태에 변화가 필요할 때 발생시킴 (객체하나로 표현)
type을 필수로 그외의 값들은 개발자 마음대로 생성

액션 생성함수 (Action Creator)
컴포넌트에서 더욱 쉽게 액션을 발생시키기 위함
필수 아님

리듀서 (Reducer)
변화를 일으키는 함수
현재의 상태와 액션을 참조하여 새로운 상태를 반환

스토어 (Store)
한 애플리케이션당 하나의 스토어
현재의 앱 상태와, 리듀서, 내장함수 포함

디스패치 (dispatch)
스토어의 내장함수
액션을 발생 시키는 것

구독 (subscribe)
스토어의 내장함수
subscribe 함수에 특정 함수를 전달해주면, 액션이 디스패치 되었을 때 마다 전달해준 함수가 호출
(리액트에서는 connect 함수 또는 useSelector Hook 을 사용)




리덕스의 3가지 규칙
리덕스를 프로젝트에서 사용하게 될 때 알아두고, 꼭 지켜야 할 3가지 규칙이 있다.

1. 하나의 애플리케이션 안에는 하나의스토어가 있다.
하나의 애플리케이션에선 단 한개의 스토어를 만들어서 사용한다. 여러개의 스토어를 사용하는것은 가능은하나 권장되는 방식은 아니다.
특정 업데이트가 빈번하게 일어나거나, 어플리케이션의 특정부분을 완전 분리시키게 될 때 여러개의 스토어를 만들 수 있다.
그렇게하면 개발도구를 온전히 활용하지 못하게된다.

2. 상태는 읽기전용이다.
리액트에서 state 를 업데이트 해야 할 때, setState 를 사용하고, 배열을 업데이트 해야 할 때는 배열 자체에 push 를 직접 하지 않고,
concat 같은 함수를 사용하여 기존의 배열은 수정하지 않고 새로운 배열을 만들어서 교체하는 방식으로 업데이트를 한다.
깊은 구조로 되어있는 객체를 업데이트를 할 때도 마찬가지로, 기존의 객체는 건드리지 않고 Object.assign 을 사용하거나
spread 연산자 (...) 를 사용하여 업데이트한다.

리덕스도 마찬가지다. 
기존의 상태는 건들이지 않고 새로운 상태를 생성하여 업데이트 해주는 방식으로 해주면,
나중에 개발자 도구를 통해서 뒤로 돌릴 수도 있고 다시 앞으로 돌릴 수도 있다.
리덕스에서 불변성을 유지해야 하는 이유는 내부적으로 데이터가 변경 되는 것을 감지하기 위하여 shallow equality 검사를 하기 때문이다.
이를 통하여 객체의 변화를 감지 할 때 객체의 깊숙한 안쪽까지 비교를 하는 것이 아니라 겉핥기 식으로 비교를 하여 좋은 성능을 유지할 수 있다.

3. 변화를 일으키는 함수, 리듀서는 순수한 함수여야한다.
순수한 함수, 라는 개념
리듀서 함수는 이전 상태와, 액션 객체를 파라미터로 받는다.
이전의 상태는 절대로 건들이지 않고, 변화를 일으킨 새로운 상태 객체를 만들어서 반환한다.
똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환해야 한다.
↑ 위의 세가지 사항을 주의해야한다.
동일한 인풋이라면 언제나 동일한 아웃풋이 있어야한다. 그런데 일부 로직들 중에서는 실행 할 때마다 다른 결과값이 나타날 수도 있다.
new Date() 를 사용한다던지, 랜덤 숫자를 생성한다던지, 네트워크에 요청을 한다던지 앞의 작업들은 순수하지 않은 작업이므로, 
리듀서 함수의 바깥에서 처리해줘야한다.

리덕스의 3가지 규칙
1.하나의 애플리케이션에 하나의 스토어

2. 상태는 읽기전용
   리액트의 불변성

3. 변화를 일으키는 함수, 리듀서는 순수한 함수
   동일한 인풋 => 동일한 아웃풋
   new Date(), 랜덤 숫자 생성, 네트워크에 요청 등은 순수하지 않은 작업(?) -> 리듀서 밖에서 처리


하나의 애플리케이션 안에는 하나의 스토어를 가져야 한다.

하나의 App에는 하나의 스토어를 만들어 사용한다.
필수는 아니지만 권장하지 않는다.
개발 도구를 활용할 수 없기 때문이다.
상태는 읽기 전용이다.

기존의 상태를 수정하지 않고 새로운 상태를 생성하여 업데이트한다. (교체의 개념)
이를 통해 불변성을 유지할 수 있다. → 데이터의 변경을 감지하기 위해서는 내부 데이터까지 전부 찾아봐야 하는데 이 경우 시간이 너무 오래 걸린다. → 따라서 기존 상태의 객체를 새로운 객체로 변경하면 객체의 주소가 다르므로 변경을 쉽게 감지하는것이 가능하다.
리듀서는 순수한 함수여야 한다.

리듀서는 이전 상태와 액션 객체를 파라미터로 받는다.
이전의 상태는 건들이지 않고 변화로 새로운 상태 객체를 만든다.
동일 인풋에 대한 동일 아웃풋이 보장되어야 한다. (순수해야 한다.)
하지만 그렇지 않은 경우도 존재한다. 이때 리덕스 미들웨어라는 것을 사용한다.



리덕스 모듈 만들기
리덕스 모듈이란 다음 항목들이 모두 들어있는 자바스크립트 파일을 의미한다.

액션 타입
액션 생성함수
리듀서

리덕스를 사용하기 위해 필요한 위 항목들은 각각 다른 파일에 저장 할 수있다.

리덕스 GitHub 레포에 등록되어있는 예제 프로젝트를 보면 다음과 같이 코드가 분리되어 있다.
리덕스 예제 프로젝트 → https://github.com/reduxjs/redux/tree/master/examples/todos/src

actions
  index.js
reducers
  todos.js
  visibilityFilter.js
  index.js

↑ 위 예제 프로젝트에서는 액션과 리듀서가 서로 다른 파일에 정의되어있다.
이 코드들이 꼭 분리되어있을 필요는 없다. 이 코드들이 서로 다른 디렉터리에 서로 다른 파일로 분리되어있으면 개발이 불편해진다.
리듀서와 액션 ㄱ솬련 코드들을 하나의 파일에 몰아서 작성하는데 이를 Ducks 패턴이라고 부른다.
Ducks패턴 → https://github.com/erikras/ducks-modular-redux
리덕스 관련 코드를 분리하는 방식은 정해져있는 방식이 없어서 자유롭게 분리해도 된다.


리액트 프로젝트에 리덕스를 적용 할 때에는 react-redux 라는 라이브러리를 사용해야한다.
$ yarn add react-redux


프리젠테이셔널 컴포넌트 만들기
프리젠테이셔널 컴포넌트란, 리덕스 스토어에 직접적으로 접근하지 않고 필요한 값 또는 함수를 props 로만 받아와서 사용하는 컴포넌트다.


컨테이너 컴포넌트 만들기
컨테이너 컴포넌트란, 리덕스 스토어의 상태를 조회하거나, 액션을 디스패치 할 수 있는 컴포넌트를 의미gksek.
HTML 태그들을 사용하지 않고 다른 프리젠테이셔널 컴포넌트들을 불러와서 사용한다.


프리젠테이셔널 컴포넌트와 컨테이너 컴포넌트
위에서 리액트 컴포넌트에서 리덕스를 사용 할 때 프리젠테이셔널 컴포넌트와 컨테이너 컴포넌트를 분리해서만들었는데, 꼭 이렇게 할 필요는 없다.
개개인이 편한대로 코드를 작성하고 개발을 하면 된다.
하지만 컴포넌트를 분리해서 작성하는것이 아직까지는 정석이기 때문에 일단은 분리해서 작성하는것이 좋다고 한다.


